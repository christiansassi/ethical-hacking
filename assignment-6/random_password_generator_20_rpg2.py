"""
# #6 RandomPasswordGenerator 2.0 (RPG2)

## Type
Reverse engineering

## Vulnerability type
There is not a precise term to pinpoint this vulnerability.
The problem is with the executable itself, which uses its PID as the seed for generating random passwords.

## Description
Can you guess the password?

## Explaination
By running the `ltrace` command, it can be observed that the program uses the `rand()` function, suggesting its potential role in password generation. 
Decompiling the executable using Ghidra yields valuable insights, particularly since the executable is not stripped.
Upon analyzing the main function, it becomes evident that the seed used to initialize the `srand()` function is the PID (Process ID) of the process.
Further analysis of the `rand_pass` function reveals the password generation mechanism. 
In fact, the password length is fixed, indicated by the fixed arg (0x10 for 16 characters). 
Finally, each character is generated using `rand() % 0x5e + 0x21`.
By using this information, the challenge can be resolved. 
The approach involves connecting to the server, retrieving the initial password, and attempting to brute force the PID (by incrementing it) until generating the same password as provided by the server. 
Once the seed is determined, generating subsequent password becomes straightforward, as it will match that generated by the server in subsequent attempts.
"""

import pwn
from ctypes import CDLL

if __name__ == "__main__":

    # Load the library
    # For now, it only works on linux.
    # On windows, by loading msvcrt, the script is not able to guess the seed
    libc = CDLL("libc.so.6")

    r = pwn.remote("cyberchallenge.disi.unitn.it", 50150)

    # Send a dummy text just to retrieve the password (first attempt)
    r.recvuntil(b":")
    r.sendline(b"dummy")
    password = r.recvline().decode()
    password = password.split("Nope, the password was: ")[1].strip()

    # Now, by analyzing the code with ghidra, we know that:
    # - the srand function is initializated using the pid of the process
    # - the password has a fixed lenght (0x10 = 16)
    # - each character of the password is calculated as (rand() % 0x5e + 0x21)

    # Now we have to find the same seed used by the process on the server to initialize srand
    # To do this, just increase the seed until we will be able to generate the same password
    pid = 0

    # Define lambda function
    generate_password = lambda rand: ''.join([chr(rand() % 0x5e + 0x21) for _ in range(0x10)])

    while True:
        libc.srand(pid)

        # Generate temp password using the current seed
        tmp_password = generate_password(libc.rand)

        # Check match
        if tmp_password == password:
            break

        pid = pid + 1

    # Generate new password (second attempt)
    password = ''.join([chr(libc.rand() % 0x5e + 0x21) for _ in range(0x10)])

    # Submit the password and retrieve the flag
    r.sendline(password.encode())
    r.recvline()
    flag = r.recvline().decode().strip()

    print(flag)